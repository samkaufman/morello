# Seeds for failure cases proptest has generated in the past. It is
# automatically read and these particular cases re-run before any
# novel cases are generated.
#
# It is recommended to check this file in to source control so that
# everyone who runs the test benefits from these saved cases.
cc 0f8ad4e96a1b742aa386a672e3ad162d629c4bd1f310dcc76a5ce9aa976fd345 # shrinks to aux = TensorSpecAux { aligned: false, level: RF, layout: Layout { dims: [(0, Dynamic), (1, Dynamic)], contig: 0 }, vector_size: None }, shape = [1], dtype = Uint8
cc a1c355977241873decae78806f69ca2d77bd22aa3ae98794b491a649b1351f1f # shrinks to aux = TensorSpecAux { aligned: false, level: VRF, layout: Layout { dims: [(1, Dynamic), (0, Dynamic), (1, Packed(2))], contig: 0 }, vector_size: Some(4) }, original_shape = [2, 5, 6], new_shape = [7, 2, 1], dtype = Uint16
cc 63fd55515c4c54fbf0ab888501b94baeed43cec0db9536af76ee51209cca7847 # shrinks to aux = TensorSpecAux { aligned: false, level: RF, layout: Layout { dims: [(0, Dynamic), (1, Dynamic)], contig: 0 }, vector_size: None }, original_shape = [4], dtype = Uint8
cc 0d80732c25f1586652490e42b5b19222ed40d6032472e8843602234db457c9de # shrinks to (spec, action) = (Spec(Primitive(PrimitiveBasics { typ: Matmul { accum: true }, spec_shape: [3, 6, 6, 8], dtypes: [Bfloat16, Sint8, Float32] }, [TensorSpecAux { level: GL, layout: Layout { dims: [(0, Dynamic), (1, Dynamic), (2, Dynamic), (1, Packed(2))], contig: 0 }, vector_size: None }, TensorSpecAux { level: VRF, layout: Layout { dims: [(0, Dynamic), (1, Dynamic), (2, Dynamic), (1, Packed(2))], contig: 1 }, vector_size: Some(16) }, TensorSpecAux { level: VRF, layout: Layout { dims: [(0, Dynamic), (1, Dynamic), (2, Dynamic), (1, Packed(2))], contig: 4 }, vector_size: Some(4) }], true), Standard(MemVec([13, 6, 8192*, 0*]))), Split(Split { k: 4 }))
cc 31e5a177d89dfad3dca25b1487d9f34b368db642feaaa469582c88edb4c621eb # shrinks to (spec, action) = (Spec(Primitive(PrimitiveBasics { typ: Matmul { accum: true }, spec_shape: [2, 1, 3, 8], dtypes: [Float32, Uint32, Sint8] }, [TensorSpecAux { level: L1, layout: Layout { dims: [(0, Dynamic), (1, Dynamic), (2, Dynamic)], contig: 2 }, vector_size: None }, TensorSpecAux { level: L1, layout: Layout { dims: [(1, Dynamic), (2, Dynamic), (0, Dynamic)], contig: 3 }, vector_size: None }, TensorSpecAux { level: GL, layout: Layout { dims: [(1, Dynamic), (2, Dynamic), (0, Dynamic)], contig: 0 }, vector_size: None }], true), Standard(MemVec([1, 1, 512*, 256*]))), Split(Split { k: 2 }))
cc d5773c504d715053c30954e843e7e6e6a2696312e6f61b7f4e7b9238205d3c2f # shrinks to (spec, action) = (Spec(Compose { components: [PrimitiveBasics { typ: Matmul { accum: true }, spec_shape: [8, 4, 5, 3], dtypes: [Sint32, Sint8, Sint32] }, PrimitiveBasics { typ: Matmul { accum: false }, spec_shape: [8, 4, 7, 5], dtypes: [Bfloat16, Float32, Sint32] }], operand_auxes: [TensorSpecAux { level: L1, layout: Layout { dims: [(0, Dynamic), (1, Dynamic), (2, Dynamic)], contig: 0 }, vector_size: None }, TensorSpecAux { level: RF, layout: Layout { dims: [], contig: 0 }, vector_size: None }, TensorSpecAux { level: RF, layout: Layout { dims: [], contig: 0 }, vector_size: None }, TensorSpecAux { level: VRF, layout: Layout { dims: [(0, Dynamic), (1, Dynamic), (2, Dynamic)], contig: 0 }, vector_size: Some(4) }], serial_only: true }, Standard(MemVec([1, 12, 16*, 0*]))), Split(Split { k: 1 }))
